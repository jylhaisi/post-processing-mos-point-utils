{
    "collab_server" : "",
    "contents" : "### SOME USEFUL DATA HANDLING FUNCTIONS ###\n\n\n\n#' Add object to a list\n#'\n#' @description\n#' This function adds objects to the end of a list\n#' @usage lappend(lst, obj, listname)\n#' @details\n#' As the list can contain miscellaneous variable types, this function should also work regardless of the variable type. No thorough tests are done, however.\n#' @param lst a list to which object is added\n#' @param obj an object which is added\n#' @param listname name of the added object as it appers in the list\n#' @return the original list with the object added\n#' @export\n#' @examples\n#' all_station_lists <- lappend(all_station_lists,loaded_list$wmon,\n#' \"mos_stations_homogeneous_Europe\")\nlappend <- function(lst, obj, listname) {\n  lst[[length(lst)+1]] <- obj\n  names(lst)[[length(lst)]] <- listname\n  return(lst)\n}\n\n\n\n#' Test if x not in y\n#'\n#' @description This is the opposite function to the \\pkg{base} inline function \\%in\\%\n#' @usage x \\%notin\\% y\n#' @details \\pkg{base} inline function \\%in\\% is in reality written as \\%in\\% <- function(x, table) match(x, table, nomatch = 0) > 0,\n#' \\%notin\\% is written simply as \\%notin\\% <- function(x,y) !(x \\%in\\% y)\n#' @param x object which is matched in y\n#' @param y the list to what x is matched against\n#' @return\n#' A vector of the same length as x. A logical vector, indicating if a match was NOT located for each element of x: thus the values are TRUE or FALSE and never NA.\n#' @export\n`%notin%` <- function(x,y) !(x %in% y)\n\n\n\n#' If x is null then return y\n#'\n#' @description This is an inline function that provides a default value in cases when the result is NULL\n#' @usage x \\%||\\% y\n#' @details The whole code of this function is `\\%||\\%` <- function(x, y) if (!is.null(x)) x else y \\cr\n#' Typical use for this inline function is to provide a default value if a function gives NULL, e.g. function_that_might_return_null() \\%||\\% default value\n#' @param x Object which may return NULL (most likely a function)\n#' @param y Default value in case of NULL\n#' @return Either the value returned by x or default value y\n#' @export\n#' @seealso \\url{http://adv-r.had.co.nz/Functions.html}\n`%||%` <- function(x, y) if (!is.null(x)) x else y\n\n\n\n#' Converting integers to a boolean list\n#'\n#' @description Which (in \\pkg{base}) converts true/false values to integers, unwhich does the opposite (n corresponds to vector length where true values are assigned to)\n#' @usage unwhich(x,n)\n#' @details The function first creates n-length list of FALSE values. After this, indices x are replaced with TRUE values.\n#' @param x Integers that indicate TRUE values\n#' @param n Boolean list length\n#' @return Boolean list with length n\n#' @export\n#' @seealso \\url{http://adv-r.had.co.nz/Subsetting.html}\n#'\nunwhich <- function(x, n) {\n  out <- rep_len(FALSE, n)\n  out[x] <- TRUE\n  out\n}\n\n\n\n#' Defining time series with fixed intervals\n#'\n#' @description Define a regularly spaced time series\n#' @usage define_time_series(begin_date, end_date, interval_in_hours)\n#' @details Use POSIXct-type date-time stamps! Time series are rounded to nearest even 3-hour ({00,03,06,09,12,15,18,21}). Default values of the parameters correspond to dates used in MOS training (begin_date = \"2011-12-01 00:00:00 GMT\", end_date = Sys.time()).\n#' @param begin_date First date of the time series\n#' @param end_date All time stamps in the time series must be smaller than this last value\n#' @param interval_in_hours Interval of two consecutive time stamps in the time series\n#' @return A regularly spaced time series\ndefine_time_series <- function(begin_date=as.POSIXct(\"2011-12-01 00:00:00 GMT\",tz=\"GMT\"),end_date=with_tz(round.POSIXt(Sys.time(),\"hours\"),tz=\"GMT\"),interval_in_hours=3) {\n  # First rounding to even hours\n  begin_date <- lubridate::with_tz(round.POSIXt(begin_date,\"hours\"),tz=\"GMT\")\n  end_date <- lubridate::with_tz(round.POSIXt(end_date,\"hours\"),tz=\"GMT\")\n  # Rounding timestamps to nearest 3 hour forecast time ({00,03,06,09,12,15,18,21})\n  begin_date <- begin_date - (as.numeric(format(round.POSIXt(begin_date, c(\"hours\")),'%H'))%%3)*3600\n  end_date <- end_date - (as.numeric(format(round.POSIXt(end_date, c(\"hours\")),'%H'))%%3)*3600\n  series <- seq(from=begin_date, to=end_date, by=paste0(interval_in_hours,\" hour\"))\n  return(series)\n}\n\n\n\n\n#' Interpolating (timeseries) values\n#'\n#' @description This is a generic NA-interpolation switch wrapper which allows the use of several interpolation methods\n#' @usage Interpolate_timeseries(data_to_be_interpolated, interpolation_method, maximum_gap, ...)\n#' @details data_to_be_interpolated is 1-dimensional (without actual time stamps). It contains NA-values for the missing time stamps. Returned data is the same size but with interpolated values.\n#' @param data_to_be_interpolated 1-dimensional data with NA values.\n#' @param interpolation_method The selected interpolation method. (\"repeat_previous\",\"linear_interp\",\"spline_interp\",\"no_interp\") are supported.\n#' @param maxgap Maximum gap (number of consecutive NA-values) allowed, which still is being interpolated\n#' @param ... Possible additional parameters passed to zoo-package interpolation functions\n#' @return Interpolated time series of same size as the input data.\ninterpolate_NA_values <- function(data_to_be_interpolated, interpolation_method, maxgap, na.rm=FALSE, ...) {\n  if (interpolation_method %!in% c(\"repeat_previous\",\"linear_interp\",\"spline_interp\",\"no_interp\")) {\n    warning(\"check obs_interpolation_method! Not interpolating!\")\n    return(data_to_be_interpolated)\n  }\n  switch(interpolation_method,\n         repeat_previous = zoo::na.locf(object=data_to_be_interpolated, ...),\n         linear_interp = zoo::na.approx(object=data_to_be_interpolated, ...),\n         spline_interp = zoo::na.spline(object=data_to_be_interpolated, ...),\n         no_interp = data_to_be_interpolated)\n}\n\n\n\n# # Very useful functions of Johanna Piipponen\n# source(\"functions_Johanna.R\")\n",
    "created" : 1494849301352.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2204969079",
    "id" : "F123D646",
    "lastKnownWriteTime" : 1499854904,
    "last_content_update" : 1499854904714,
    "path" : "~/statcal/R_projects/MOSpointutils/R/functions_useful.R",
    "project_path" : "R/functions_useful.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}